% feasibility-report.tex: 可行性报告
% Copyright (C) 2022 吴骏东, 张子辰, 蓝俊玮, 郭耸霄 and 陈建绿
% All rights reserved.

% This file is part of Runikraft. Runikraft is free software,
% which is released under the BSD 3-Clause License, see LICENSE for details.
% Runikraft is provided ``as is'', without any express or implied warrenties.

% The reports of Runikraft are released under the Creative Commons
% Attribution 4.0 International License; see report/LICENSE for details.
\documentclass[UTF8,fontset=none,linespread=1.15]{ctexart}
\ctexset
{
    section/format={\Large\sffamily\bfseries},
    subsection/format+={\sffamily},
    subsubsection/format+={\itshape}
}
\setCJKmainfont[ItalicFont={KaiTi},BoldItalicFont={KaiTi},
BoldItalicFeatures={FakeBold=3}]{Noto Serif CJK SC}
\setCJKsansfont[BoldFont={Noto Sans CJK SC Bold},
BoldItalicFont={Noto Sans CJK SC Bold},
AutoFakeSlant]{Noto Sans CJK SC DemiLight}
\setCJKmonofont[AutoFakeBold=3,AutoFakeSlant]{FangSong}
\setmainfont{cmun}[Extension=.otf,UprightFont=*rm,
ItalicFont=*ti,BoldFont=*bx,BoldItalicFont=*bi]
\setsansfont{cmun}[Extension=.otf,UprightFont=*ss,
ItalicFont=*si,BoldFont=*sx,BoldItalicFont=*so]
\setmonofont{cmun}[Extension=.otf,UprightFont=*btl,
ItalicFont=*bto,BoldFont=*tb,BoldItalicFont=*tx]
%Computer Modern Unicode 的\textasciitilde和\~{}的高度相同，所以用\tildechar表示居中的波浪线~
\newcommand{\tildechar}{\raisebox{-0.35em}{\textasciitilde}}
\usepackage[a4paper,hmargin=1.2in,vmargin=1in]{geometry}
\usepackage{graphicx,tikz,float,multicol,makecell,multirow,longtable}
\usepackage{verbatim}
\usepackage[normalem]{ulem}
\usepackage{CJKfntef}
\usepackage[perpage]{footmisc}

%目录, 参考了OSH-2021/x-sBPF
\usepackage{titletoc}
\titlecontents{section}[2em]{\addvspace{1.3mm}\bfseries}{%
\contentslabel{2.0em}}{}{\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{subsection}[4.2em]{}{\contentslabel{2.5em}}{}{%
\titlerule*[5pt]{$\cdot$}\contentspage}
\titlecontents{subsubsection}[7.2em]{}{\contentslabel{3.3em}}{}{%
\titlerule*[5pt]{$\cdot$}\contentspage}

%图表标题
\usepackage{caption}
\captionsetup{font={sf}}

%代码环境
\usepackage{listings}
\lstset{basicstyle={\normalfont\ttfamily},breaklines,tabsize=4}
\renewcommand{\lstlistingname}{代码}
\renewcommand{\lstlistlistingname}{代码}
%Rust
\lstdefinelanguage{Rust}
{
    morekeywords={as,async,await,break,const,continue,crate,dyn,else,enum,extern,false,fn,for,if,impl,in,let,loop,match,mod,move,mut,pub,ref,return,Self,self,static,struct,super,trait,true,type,union,unsafe,use,where,while,abstract,become,box,do,final,macro,override,priv,try,typeof,unsized,virtual,yield},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]{"},
    morestring=[b]{'}
}


\usepackage{enumitem}
\setlistdepth{5}
\renewlist{enumerate}{enumerate}{5}
\setlist{itemsep=0pt,partopsep=0pt,parsep=0pt,topsep=0pt}
\setlist[enumerate,1]{label=\arabic*.}
\setlist[enumerate,2]{label=(\arabic*)}
\setlist[enumerate,3]{label=\textcircled{\arabic*}}
\setlist[enumerate,4]{label=(\textit{\roman*})}
\setlist[enumerate,5]{label=\textit{\alph*})}

\usepackage[colorlinks,unicode,pdfstartview={FitH}]{hyperref}
\hypersetup
{
  pdftitle={2022春 操作系统原理与设计(H) x-runikraft小组 可行性报告},
  pdfauthor={吴骏东; 张子辰; 蓝俊玮; 郭耸霄; 陈建绿}
}

%带圈数字，它必须在hyperref之后载入
\usepackage{xunicode-addon}
\makeatletter
\xeCJKDeclareCharClass{CJK}{"24EA, "2460->"2473, "3251->"32BF,"24B6->"24E9,"2160->"217F}
\newfontfamily\EnclosedNumbers{Noto Serif CJK SC}
\AtBeginUTFCommand[\textcircled]{\begingroup\EnclosedNumbers}
\AtEndUTFCommand[\textcircled]{\endgroup}
\makeatother

\makeatletter
\let\textcircled@old\textcircled
\protected\def\textcircled#1{%
	\expandafter\textcircled@old\expandafter{\expanded{#1}}}
\makeatother
\makeatletter
\renewcommand\@makefntext[1]{%
	\setlength\parindent{0.75\ccwd}\selectfont
	\@thefnmark\ #1}
\makeatother
\renewcommand*\thefootnote{\textcircled{\arabic{footnote}}}
\renewcommand{\lstlistingname}{代码}

%上标+引用
\let\nosupcite\cite
\renewcommand*{\cite}[1]{\textsuperscript{\nosupcite{#1}}}

%章节作者
\newcommand{\sectionauthor}[1]{%
\vspace*{-5ex}
\noindent\textrm{\hfill\textit{by #1}}
\vspace*{2ex}\par}
%\renewcommand{\today}{2022年4月5日}

\begin{document}
\sffamily %为方便屏幕阅读，文档主要使用无衬线字体
\title{\bfseries Runikraft小组\quad 可行性报告}
\author{吴骏东\and 张子辰\and 蓝俊玮\and 郭耸霄\and 陈建绿}
\date{\today}
\maketitle

\tableofcontents
\section{项目介绍}
我们选择的课题是使用Rust语言改写Unikraft Unikernel。与RustyHermit和rCore等用Rust实现的操作系统不同，
我们将完全使用Rust的稳定特性编写代码。

众所周知，在互联网技术和云计算不断发展的今天，我们身边的虚拟化设备不断增多，
它们中的很多都使用了Unikernel。然而，虚拟化设备和Unikernel也暴露出了很多安全问题。
对这些安全问题，C语言因其本身的缺陷难辞其咎。

Rust 是一门让人人都能写出可靠、高效的软件的语言。\cite{7}利用Rust编写Unikernel，
可以充分发挥它相对C语言的高层抽象和内存安全保证。用Rust改写项目已经成为一种解决问题的
有效手段，如zalando公司从Scala转向Rust的成功故事。\cite{3}

RISC-V是一款自由、开源的ISA，它开启了全新的基于开放标准协作的处理器创新时代。\cite{0}
目前基于RISC-V架构的开源处理器有很多，既有标量处理器Rocket，
也有超标量处理器BOOM，还有面向嵌入式领域的Z-scale、PicoRV32等。\cite{2}

因此，我们计划使用Rust语言改写架构和性能方面占优的unikernel——Unikraft。
在这份报告中，我们将首先介绍项目的理论依据——Rust语言适用于系统编程的特性
及对Unikraft源码的分析和改写思路；随后，我们将介绍使用QEMU进行硬件仿真和
测试的方法；最后，我们将给出项目的总体设计和创新点。
\section{理论依据}
\subsection{Rust语言}
\subsubsection{保证内存安全的方式}
在高级语言中，某个内存位置要在程序中能被访问，必然就会与一个或多个变量建立关联关系。这会引出内存的不正确访问引发的内存安全问题。这些问题在C/C++中都是需要开发者非常小心地自己处理。而 Rust 的语言特性则为上面的问题提供了解决方案。\cite{8}
\begin{table}[H]
\centering
\caption{Rust对内存安全问题的解决方案}
\begin{tabular}{|c|c|}
\hline
\textbf{问题} & \textbf{Rust 的解决方案}\\\hline
使用未初始化内存&编译器禁止变量读取未赋值变量\\\hline
对空指针解引用&使用\texttt{Option}枚举替代空指针\\\hline
悬垂指针&生命周期标识与编译器检查\\\hline
缓冲区溢出&编译器检查，拒绝超越缓冲区边界的数据访问\\\hline
非法释放内存&语言级的 RAII 机制，唯一的所有者才有权释放内存\\\hline
\end{tabular}
\end{table}
\subsubsection{保证线程安全的方式}
Rust 通过一整套设计非常精良的基础设施来保证这一点，这些基础设施配合类型检查和借用模型“强迫”程序员写出正确的代码，把别的语言在运行时的崩溃或泄露暴露在编译期，从而保证线程安全。

\noindent 基础设施：

\begin{enumerate}
\item 进行语义限制的\texttt{Send} / \texttt{Sync} 、\texttt{Trait}。
\item 共享不可变所有权的\texttt{Arc} (\texttt{Rc}的多线程版本)。
\item 提供内部可变性的\texttt{Mutex} / \texttt{Rwlock}。
\item 管道模型\texttt{channel}。
\item 其他的一些线程相关的API。
\end{enumerate}

\noindent 线程相关的常见API与设施：

\begin{enumerate}
\item \texttt{std::thread::spawn}，\texttt{spawn}接收一个闭包并执行,返回一个\texttt{JoinHandle}类型的值，它拥有线程所有权；
\item  \texttt{join()}函数，该函数作用在线程句柄\texttt{JoinHandle}类型的值上，使得父线程能够等待子线程执行完毕；
\item \texttt{move}+闭包，\texttt{move}闭包常常与\texttt{thread}和\texttt{spawn}一起使用，它允许我们在一个线程中使用另外一个线程的数据，使用\texttt{move}关键字强制闭包获取其使用的环境值的所有权。
\end{enumerate}

Rust 所拥有的这些设施以及自身的特性可以让我们编写出正确的代码从而保证线程安全。\cite{9}

\subsubsection{Unsafe Rust}
在进行底层系统编程时，我们必须要使用Rust 的unsafe关键字，使用该关键字可以使我们实现以下功能：

解引用原生指针，这对于和C语言和汇编语言程序交互很有用。
调用一个不安全的函数或方法（例如C语言函数）。
访问和修改静态变量，后者是Rust中的"全局变量"。
使用Unsafe Rust会在一定程度上减少Rust编译器的安全检查，但牺牲的稍许安全性却可以换来灵活性的巨大提高。在与硬件抽象（定义于\texttt{portmacros.h}中）进行交互时，我们可能需要使用这个特性。

\subsection{Rust与C交互}
Rust 中提供了\texttt{extern}关键字来简化创建和使用外部接口（Foreign Function Interface, FFI）的过程。FFI 是编程语言定义函数的一种方式，它允许其他（外部的）编程语言来调用这些函数。
下面是一个集成了C标准库中的\texttt{abs}函数的示例代码：
\begin{lstlisting}[numbers=left]
	extern "C" {
		fn abs(input: i32) -> i32;
	}
	fn main(){
		unsafe {
			println!("Absolue value of -3 according to C: {}", abs(-3));
		}
	}
\end{lstlisting}
这段代码在\texttt{extern "C"}块中列出了它想要调用的外部函数和签名，其中的\texttt{"C"}指明了外部函数使用的应用二进制接口（Application Binary Interface, ABI）：它被用来定义函数在汇编层面的调用方式。

要在其他语言中调用 Rust 函数，同样可以使用\texttt{extern}来创建一个允许其他语言调用 Rust 函数的接口。创建时需要将\texttt{extern}关键字及对应的 ABI 添加到函数签名的\texttt{fn}关键字前，并为该函数添加\texttt{\#[no\_mangle]}注解来避免 Rust 在编译时改变它的名称。下面是一个可以在编译并链接后被 C 语言代码访问的函数定义：
\begin{lstlisting}[numbers=left]
	#[no_mangle]
	pub extern "C" fn call_from_c() {
		println!("Just called a Rust function from C!");
	}
\end{lstlisting}
这一类型的\texttt{extern}功能不需要使用\texttt{unsafe}。

\subsection{Rust的条件编译}
Rust通过cfg属性，对条件编译提供了支持。这些配置在Cargo.toml中提供，例如：

\begin{lstlisting}[numbers=left]
[features]
# no features by default
default = []

# The “secure-password” feature depends on the bcrypt package.
secure-password = ["bcrypt"]

# A feature with no dependencies is used mainly for conditional 	 compilation, like `#[cfg(feature = "go-faster")]`.
go-faster = []
\end{lstlisting}

在代码中，可以采用cfg属性修饰函数：
\begin{lstlisting}[numbers=left]
// This function is only included when compiling for a unixish OS with a 32-bit architecture
#[cfg(all(unix, target_pointer_width = "32"))]
fn on_32bit_unix() {
	// ...
}
也可以使用以下类似#ifdef的方式进行条件编译：

let machine_kind = if cfg!(unix) {
	"unix"
} else if cfg!(windows) {
	"windows"
} else {
	"unknown"
};

println!("I'm running on a {} machine!", machine_kind);
\end{lstlisting}
\cite{e}

\subsection{RISC-V ISA}
\subsubsection{特权特权模型}
在编写unikernel时，我们需要使用特权指令处理外设中断、控制机器状态，
因此需要了解RISC-V的特权模型。

截至目前(2022.4)，RISC-V 共定义了四个特权级别，由高到低排列顺次为：

\begin{description}
\item[机器级别（M）] RISC-V中硬件线程可以执行的最高权限模式。
在M模式下运行的 hart 对内存、I/O 和一些对于启动和配置系统来说必要的底层
功能有着完全的使用权。因此它是唯一所有标准 RISC-V 处理器都必须实现的权限模式。\cite{a}
\item[超级监管者级别（H）] 为了支持虚拟机监视器。但目前该级别并没有被正式加入到文档中。
\item[监管者级别（S）] 为了支持现代类 Unix 操作系统，如 Linux，FreeBSD 和 Windows 。
\item[用户级别（U）] 用于运行应用程序，适用于安全嵌入式系统。
\end{description}

标准的 RISC-V 为超过4000个 CSR 预留了12位的编码空间(\texttt{[11：0]})。
其中，\texttt{[11：8]} 位根据特权级别对 CSR 的读写权限进行编码。
注意：任何试图访问不存在的 CSR 的行为均会引发指令异常，尝试写入只读寄存器也会引发指令异常。
剩余的8位编码 \texttt{[7:0]} 将指定相应的寄存器地址位置。具体细节如下所示：\cite{b}\cite{c}

\begin{lstlisting}[numbers=left]
CSR [11:10]：对读写模式进行约束
00		read/write
01		read/write
10		read/write
11		read-only
CSR [9:8]：对访问最低权限进行约束
00		Unprivileged and User-Level CSRs
01		Supervisor-Level CSRs
10		Hypervisor and VS CSRs
11		Machine-Level CSRs
\end{lstlisting}


目前 RISC-V 支持的特权指令格式为：
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{assets/W2}
	\caption{目前 RISC-V 支持的特权指令格式}
	\label{fig:w2}
\end{figure}
以 CSR 访存指令为例。其标准格式为：
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{assets/W3}
	\caption{ CSR 访存指令为例的标准格式}
	\label{fig:w3}
\end{figure}
除目前 RISC-V 支持的特权指令格式外，\texttt{ecall}指令在Linux中用于系统调用。

\subsubsection{监管者二进制接口}
为了降低S模式的程序在不同RISC-V的设备之间的移植难度，
RISC-V引入了监管者二进制接口（\textbf{S}upervisor \textbf{B}inary \textbf{I}nterface）。
它在M模式运行，为运行在S模式下的操作系统内核提供硬件抽象。

与U模式的程序使用系统调用陷入S模式类似，S模式的系统内核也可以用SBI调用陷入M模式，
以使用SBI提供的服务。

\begin{figure}[tbh!]
\centering
\includegraphics[width=0.7\linewidth]{assets/RISCV-SBI}
\caption{不含H拓展的RISC-V系统}
\label{fig:riscv-sbi}
\end{figure}

如下为\texttt{arch/riscv/kernel/sbi.c}中的部分代码，使用\texttt{ecall}指令时，
将EID写在\texttt{a7} 寄存器，FID写在\texttt{a6}寄存器，参数写在 \texttt{a0}-\texttt{a5} 寄存器，
后面会根据EID和FID的不同调用不同的处理函数。
\begin{lstlisting}[language=C,numbers=left]
struct sbiret sbi_ecall(int ext, int fid, unsigned long arg0,
unsigned long arg1, unsigned long arg2,
unsigned long arg3, unsigned long arg4,
unsigned long arg5)
{
	struct sbiret ret;

	register uintptr_t a0 asm ("a0") = (uintptr_t)(arg0);
	register uintptr_t a1 asm ("a1") = (uintptr_t)(arg1);
	register uintptr_t a2 asm ("a2") = (uintptr_t)(arg2);
	register uintptr_t a3 asm ("a3") = (uintptr_t)(arg3);
	register uintptr_t a4 asm ("a4") = (uintptr_t)(arg4);
	register uintptr_t a5 asm ("a5") = (uintptr_t)(arg5);
	register uintptr_t a6 asm ("a6") = (uintptr_t)(fid);
	register uintptr_t a7 asm ("a7") = (uintptr_t)(ext);
	asm volatile ("ecall"
	: "+r" (a0), "+r" (a1)
	: "r" (a2), "r" (a3), "r" (a4), "r" (a5), "r" (a6), "r" (a7)
	: "memory");
	ret.error = a0;
	ret.value = a1;

	return ret;
}
\end{lstlisting}​

例如可以用如下程序实现一个打印一个字符到系统控制台上的putchar函数：
\begin{lstlisting}[language=C]
    void sbi_console_putchar(int ch)
    {
    	sbi_ecall(SBI_EXT_0_1_CONSOLE_PUTCHAR, 0, ch, 0, 0, 0, 0, 0);
    }
\end{lstlisting}

用SBI可以降低开发系统的难度，但是会引入\texttt{ecall}指令，而unikernel的高效正是
依靠避免\texttt{ecall}实现的，所以我们只会在前期使用SBI提供的服务，后期会用自己编写
的virtio驱动程序代替SBI。


\subsubsection{KVM对RISC-V架构的支持}
KVM (Kernel-based Virtual Machine，基于内核的虚拟机)  ，是一种内建于 Linux 中的开源虚拟化技术。具体而言，KVM 可以将 Linux 转变为虚拟监控程序，从而使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。
\begin{figure}[!hbt]
	\centering
	\includegraphics[width=0.7\linewidth]{assets/W4}
	\caption{虚拟化下的特权等级}
	\label{fig:w4}
\end{figure}

如图\ref{fig:w4}，为了支持虚拟化，RISC-V 规范定义了 RISC-V H-extension ，在原来的3级特权架构的基础上对原有的 Supervisor 模式进行了扩展，引入了 Hypervisor-Extended Supervisor mode(HS)。此时，在 Machine Mode 下运行最高优先级的、对全部资源具备操作能力的 Firmware ，虚拟机软件 Hypervisor 运行在 HS 模式，虚拟机 VM 运行在虚拟化的 Supervisor 模式，应用程序继续运行在虚拟操作系统之上，运行在 Virtualized User mode。

为了实现 Supervisor 与 Hypervisor-extended supervisor 模式的切换，RSIC-V 将原来 Supervisor 模式下的 CSR 复制一份到Hypervisor，从而让每个硬件线程拥有两份 supervisor 寄存器，加快两个模式之间的切换过程。

由于 RISC-V 没有为不同虚拟化软件设计专门的特权模式，而是设计了统一的特权模式，这说明它对 1类（如Xvisor）、 2类（如KVM）虚拟化软件都有很好的支持。 RISC-V 可以通过 CSR 寄存器注入中断，因此不需要为虚拟化而特殊设计中断控制器外设。此外，RISC-V 可直接借助特殊的寄存器位支持嵌套虚拟化，而 Aarch64 要等到 v8.3 版本之后才支持这个功能。RISC-V 的时钟和核间中断可通过 SBI 软件辅助完成，而 Aarch64 需要特殊设计的计时器外设来支持虚拟化功能。\cite{d}

\subsubsection{使用QEMU进行仿真测试}

QEMU is a generic and open source machine emulator and virtualizer.

When used as a machine emulator, QEMU can run OSes and programs made for one machine (e.g. an ARM board) on a different machine (e.g. your own PC). By using dynamic translation, it achieves very good performance.

When used as a virtualizer, QEMU achieves near native performance by executing the guest code directly on the host CPU. QEMU supports virtualization when executing under the Xen hypervisor or using the KVM kernel module in Linux. When using KVM, QEMU can virtualize x86, server and embedded PowerPC, 64-bit POWER, S390, 32-bit and 64-bit ARM, and MIPS guests.\cite{1}

\noindent QEMU具有如下优点：

\begin{description}
\item[Full-system emulation] Run operating systems for any machine, on any supported architecture.
\item[User-mode emulation] Run programs for another Linux/BSD target, on any supported architecture.
\item[Virtualization] Run KVM and Xen virtual machines with near native performance.\cite{1}
\end{description}

\subsection{Unikraft架构分析}
\subsubsection{代码风格}
Unikraft的代码组织方式充分体现了模块化设计，核心代码被放在了\texttt{arch/}、\texttt{include/}和
\texttt{plat/}三个目录下，而系统的几乎所有功能都由为了\texttt{lib/}目录下的micro-libraries提供。
一个micro-library被放在一个目录下：
\begin{itemize}
\item \texttt{include/}：micro-libray的API；
\item \texttt{Config.uk}：menu-config配置；
\item \texttt{exportsyms.uk}：导出的符号；
\item \texttt{Makefile.uk}：自动构建系统的配置；
\item \texttt{*.c}：micro-library的实现。
\item \texttt{extra.ld}：（可选）链接器配置。
\end{itemize}

比如，\texttt{rksched}的目录结构：
{\linespread{1}
\begin{verbatim}
    uksched
    ├── Config.uk
    ├── exportsyms.uk
    ├── extra.ld
    ├── include
    │   └── uk
    │       ├── sched.h
    │       ├── thread_attr.h
    │       ├── thread.h
    │       ├── wait.h
    │       └── wait_types.h
    ├── Makefile.uk
    ├── sched.c
    ├── thread_attr.c
    └── thread.c
\end{verbatim}}

Unikraft用UNIX命名风格，函数名和结构体
以\texttt{uk\_\hspace{0cm}\textit{<micro-library\hspace{0cm}名\hspace{0cm}>}\hspace{0cm}\_}
开头，结构体名后\textit{通常}附加\texttt{\_t}，
比如\texttt{uk\_malloc}、\texttt{uk\_alloc\_malloc\_func\_t}。
Unikraft使用面向对象设计，每个micro-libray中通常有与库同名的结构体，如\texttt{uk\_sched}，
库中的函数的第一个参数通常是执行这个结构体的指针，如\texttt{\textbf{struct} uk\_sched *uk\_sched\_create(\textbf{struct} uk\_alloc *a, \textbf{size\_t} prv\_size)}。

\subsubsection{编译运行流程}
以编译\href{https://github.com/unikraft/app-helloworld}{hello world程序}为例，介绍编译并运行基于Unikraft的unikernel的流程。

首先要修改\texttt{Makefile}，把\texttt{UK\_ROOT}改为unikraft源代码的目录，比如
\texttt{UK\_ROOT ?= \linebreak\$(PWD)/../unikraft}，当然也可以不修改\texttt{Makefile}而修改
命令行参数。

用\texttt{make menuconfig}配置，然后用\texttt{make}编译。
\begin{figure}[!hbt]
\centering
\includegraphics[width=0.9\linewidth]{assets/unikraft-menuconfig}
\caption{配置Unikraft}
\label{fig:unikraft-menuconfig}
\end{figure}
Hello world程序与Unikraft的各个被使用的micro-libraies先被分别编译成了\texttt{.o}文件，
再链接成一个unikernel镜像。一共生成了\texttt{libkvmplat}、\texttt{libkvmpci}、\texttt{libkvmvirtio}、
\texttt{apphelloworld}、\texttt{libnolibc}、\texttt{libukalloc}、\texttt{libukallocbbuddy}、
\texttt{libukargparse}、\texttt{libukboot}、\texttt{libukbus}、\texttt{libukdebug}、
\texttt{libuksglist}、\texttt{libuktime}、\texttt{libuktimeconv}、\texttt{libx86\_64arch}等中间文件。
最后的输出是18.0KiB大的\texttt{app-\linebreak helloworld\_kvm-x86\_64.gz}。

详细的编译日志位于我们的仓库的\href{https://github.com/OSH-2022/x-runikraft/tree/d22ccf0c1b248667148fd8953b71b6e0258de6a3/reference/Unikraft%20helloworld}{reference/Unikraft helloworld/}目录。

用\texttt{qemu-system-x86\_64 -kernel build/app-helloworld\_kvm-x86\_64 -nographic}\linebreak 运行hello world程序。

\begin{figure}[tbh!]
\centering
\includegraphics[width=0.9\linewidth]{assets/unikraft-run}
\caption{运行hello world}
\label{fig:unikraft-run}
\end{figure}


\subsubsection[开机流程]{开机流程（KVM+AMD64）}
\begin{enumerate}
\item bootloader（由虚拟机的固件实现）。
\item \texttt{\_libkvmplat\_start32}（位于\texttt{plat/kvm/x86/entry64.S}）：
    \begin{enumerate}
    \item enable pae；
    \item enable long mode；
    \item load pml4 pointer；
    \item enable paging；
    \item \texttt{jmp \_libkvmplat\_start64}。
    \end{enumerate}
\item \texttt{\_libkvmplat\_start64}：
    \begin{enumerate}
    \item 一系列复杂的初始化；
    \item \texttt{call \_libkvmplat\_entry}。
    \end{enumerate}
\item \texttt{\_libkvmplat\_entry}（位于\texttt{plat/kvm/x86/setup.c}），它接受\texttt{struct multiboot\_info*}参数：
    \begin{enumerate}
    \item \texttt{\_init\_cpufeatures}；
    \item \texttt{\_libkvmplat\_init\_console}；
    \item \texttt{traps\_init}；
    \item \texttt{intctrl\_init}；
    \item \texttt{\_mb\_get\_cmdline}：把multiboot\_info中的命令行参数复制到数据段的\texttt{char\linebreak cmdline[8192]}；
    \item \texttt{\_mb\_init\_mem}：处理与内存分段有关的操作；
    \item \texttt{\_mb\_init\_initrd`}；
    \item (\texttt{CONFIG\_HAVE\_SMP})\footnote{表示在开启某个配置时执行。} \texttt{acpi\_init}；
    \item (\texttt{CONFIG\_HAVE\_SYSCALL}) \texttt{\_init\_syscall}；
    \item (\texttt{CONFIG\_HAVE\_X86PKU}) \texttt{\_check\_ospke}；
    调用\texttt{\_libkvmplat\_newstack}从引导栈切换走。
    \end{enumerate}
    可以看出，AMD64的开机流程很复杂，在ARMv8中，系统的起点是用汇编语言编写
    的\texttt{\_libkvmplat\_entry}，它调用用C语言编写的\texttt{\_libkvmplat\_start}，
    之后的流程与AMD64相同。
\item \texttt{\_libkvmplat\_entry2}：把cmdline传递给\texttt{ukplat\_entry\_argp}。
\item \texttt{ukplat\_entry\_argp}：把命令行参数拆成argc+argv的形式，然后调用\texttt{ukplat\_entry}。
\item \texttt{ukplat\_entry}：
    \begin{enumerate}
    \item 调用\texttt{ctorfn}注册的构造函数（\texttt{ctors.h}提供了注册构造函数的机制）；
    \item (\texttt{CONFIG\_LIBUKLIBPARAM})进一步分析命令行参数；
    \item (\texttt{!CONFIG\_LIBUKBOOT\_NOALLOC}) 依次尝试在每一块内存区域上初始化分配器\linebreak（\texttt{uk\_<name>\_init}），成功创建分配器后，将剩余的内存区域加入分配器\linebreak（\texttt{uk\_alloc\_addmem}）；
    \item (\texttt{CONFIG\_LIBUKALLOC}) 初始化中断（\texttt{ukplat\_irq\_init}）；
    \item (\texttt{CONFIG\_LIBUKSCHED}) 初始化调度器\texttt{uk\_sched\_default\_init}；
    \item (\texttt{CONFIG\_LIBUKSCHED}?)
        \begin{itemize}
        \item (true)  创建主线程（执行\texttt{main\_thread\_func}）→启动调度器（\texttt{uk\_sched\_start}），
        \item (false) 启动中断（\texttt{ukplat\_lcpu\_enable\_irq}）→直接调用\texttt{main\_thread\_func}。
        \end{itemize}
    \end{enumerate}
\item \texttt{main\_thread\_func}：
    \begin{enumerate}
    \item 调用init table上注册的函数（由\texttt{init.h}提供，与\texttt{ctorfn}类似）；
    \item (\texttt{CONFIG\_LIBUKSP})\texttt{uk\_stack\_chk\_guard\_setup}；
    \item 调用用户程序的构造函数 \texttt{\_\_preinit\_array}和\texttt{\_\_init\_array}；
    \item 调用用户程序的\texttt{main}。
    \end{enumerate}
\item \texttt{main}。
\item 关机/崩溃。
\end{enumerate}

\subsubsection{分配器}
分配器的API位于\texttt{ukalloc}，可选的实现有\texttt{ukallocbbuddy}、\texttt{ukallocpool}、
\texttt{ukallocregion}。\texttt{ukalloc}用函数指针实现了类似C++的虚函数的运行时绑定，其他的
Unikraft 接口micro-libraries也采用了类似的技术。\texttt{\textbf{struct} uk\_alloc}保存
\texttt{malloc}、\texttt{free}等指向实现的函数指针，\texttt{uk\_malloc}等接口函数
接受\texttt{uk\_alloc}型指针\texttt{a}，将参数转发给\texttt{a}的函数指针。比如，\texttt{malloc}的
实现：
\begin{lstlisting}[language=C]
static inline void *uk_do_malloc(struct uk_alloc *a, __sz size)
{
	UK_ASSERT(a);
	return a->malloc(a, size);
}

static inline void *uk_malloc(struct uk_alloc *a, __sz size)
{
	if (unlikely(!a)) {
		errno = ENOMEM;
		return __NULL;
	}
	return uk_do_malloc(a, size);
}
\end{lstlisting}

具体的实现负责初始化\texttt{uk\_alloc}变量，比如\texttt{ukbbuddy}实现了伙伴分配器，它提供的
\texttt{struct uk\_alloc *uk\_allocbbuddy\_init(void *base, size\_t len)}函数会把
自己的实现绑定到\texttt{uk\_alloc}中的函数指针。

\subsubsection{调度器}
调度器和线程的APIs都位于\texttt{uksched}。

\texttt{ukthread}既是接口又是实现，它提供针对单个线程的操作，
其中的\texttt{\textbf{struct} uk\_thread}保存线程控制块，
\texttt{uk\_thread\_set\_timeslice}函数设置线程时间片，\texttt{uk\_thread\_wake}
函数唤醒线程，根据线程的时间片设置定时器，然后把控制权转交给这个线程，这些操作需要调用\texttt{ukplat}
的API。

\texttt{uksched}是只是接口，它
负责管理所有线程，它调用\texttt{ukthread}的API操作单个线程。
\texttt{ukschedcoop}是\texttt{uksched}的实现之一，它实现了最基本非抢占式的时间片轮转线程调度器。
它使用双链尾队列（tail queue）维护所有线程（\texttt{thread\_list}）和
睡眠状态（就绪或等待）的线程（\texttt{sleeping\_threads}）。
每一轮调度，\texttt{ukschedcoop}从睡眠线程队列
中找出一个处在就绪态的线程，并唤醒（\texttt{uk\_thread\_wake}）这个线程，
如果没有任何能执行的线程，就挂起CPU（\texttt{ukplat\_lcpu\_halt\_to}），
直到某个线程能执行。\texttt{ukschedcoop}并不需要为每一个事件维护等待队列，
因为即使线程等待的事件发生了，由于当前线程的执行不能被抢占，等待的线程也不能被立即唤醒。

Unikraft的论文中提到了它拥有抢占式调度器\texttt{ukpreempt}，但是我们并没有在它的源代码中找到相应的实现。

\section{技术依据}
\subsection{rustc交叉编译}
先安装交叉编译riscv64gc的编译器组件，
然后在编译时附加\texttt{--target riscv64gc-\linebreak unknown-none-elf}选项即可实现x86-64--riscv64交叉编译。

还需要安装\texttt{rust-objcopy}以生成QEMU能加载的原始二进制文件。

\noindent 命令（假定已安装通过rustup安装Rust构建工具链）：
\begin{lstlisting}
rustup target add riscv64gc-unknown-none-elf
cargo install cargo-binutils
\end{lstlisting}

\subsection{启动操作系统}
添加编译选项\texttt{-Clink-arg=-Tlinker.ld}以便链接器能读取自定义的链接脚本：
\begin{multicols}{2}
\begin{lstlisting}
OUTPUT_ARCH(riscv)
ENTRY(__runikraft_start)
BASE_ADDRESS = 0x80200000;

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    . = ALIGN(4K);
    erodata = .;
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    . = ALIGN(4K);
    edata = .;
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }

    . = ALIGN(4K);
    ebss = .;
    ekernel = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
\end{lstlisting}
\end{multicols}

初始化函数需要用汇编语言编写：
\begin{lstlisting}[numbers=left]
.extern sbss
.extern ebss

.section .text.entry
.globl __runikraft_start

__runikraft_start:
    #清空bss段
    la t0,sbss
    la t1,ebss
    clean_bss:
        bge t0,t1,clean_bss_end
        sd x0,(t0)
        addi t0,t0,8
        j clean_bss
    clean_bss_end:
    addi t0,zero,0
    addi t1,zero,0
    #加载栈指针
    la sp,stack_top
    call __runikraft_entry_point

.section .bss.stack
    .space 65536
stack_top:
\end{lstlisting}
它加载栈指针，然后将控制权转交给用Rust写的更高层的初始化函数。目前后者还只有雏形，它只初始化\texttt{rk::plat}模块
的定时器子模块，然后调用用户程序的入口\texttt{main}。
\begin{lstlisting}[language=Rust,numbers=left]
/// 系统的入口，由引导程序调用
///
#[no_mangle]
pub fn __runikraft_entry_point()->!{
    time::init();
    unsafe{main();}
    halt();
}
\end{lstlisting}

\texttt{\_\_runikraft\_entry\_point}和\texttt{\_\_runikraft\_start}都是Runikraft核心组件的
\texttt{plat::\linebreak bootstrap}的一部分，目前的核心组件还已经实现了\texttt{plat::console}和
\texttt{plat::time}两个\texttt{plat}模块的子模块，以及\texttt{bitcount}模块（这个模块完全是
对Unikraft的\texttt{bitcount.c}的翻译）。目前已经实现了\texttt{rkalloc} API（对应Unikraft的
\texttt{ukalloc}，这个API有一个演示用的“空实现”\texttt{rkalloc\_empty}。

目前的\texttt{main}函数能简单演示\texttt{plat::console}、\texttt{plat::time}和\texttt{rkalloc}：
\begin{lstlisting}[language=Rust,numbers=left]
#![no_std]
#![no_main]

use runikraft as rk;

use rkalloc::RKalloc;
use rkalloc_empty::RKallocEmpty;
use rk::plat::time;

static mut HEAP_SPACE: [u8;1000] = [0;1000];

#[no_mangle]
fn main() {
    let mut alloc;
    unsafe {
        alloc = RKallocEmpty::new(HEAP_SPACE.as_mut_ptr(),1000);
    }
    rk::println!("Hello, world!");
    let p1 = unsafe{alloc.malloc(10)};
    rk::println!("p1={:?}",p1);
    let p2 = unsafe{alloc.malloc(5)};
    rk::println!("p2={:?}",p2);
    rk::println!("sleep for 10s");
    let start = time::get_ticks();
    loop {
        if (time::get_ticks() - start).as_secs()>=10 {break;}
    }
    let end = time::get_ticks();
    rk::println!("slept for {:?}",end - start);
}
\end{lstlisting}

\subsection{编译}
依次运行
\begin{lstlisting}
cargo build --release
rust-objcopy --strip-all build/riscv64gc-unknown-none-elf/release/dev-test -O binary build/riscv64gc-unknown-none-elf/release/dev-test.bin
\end{lstlisting}
即可完成编译。

\subsection{运行和调试}
这一步需要QEMU \texttt{riscv64}、\texttt{riscv64-unknown-elf}GDB和OpenSBI的
\texttt{fw\_jump.bin}。QEMU可以用\texttt{sudo apt install qemu-system-misc}安装，
当然也可以用\texttt{sudo apt install qemu-system}完整地安装QEMU。符合要求的GDB并没有
被收录在Ubuntu的软件源中，幸好SiFive提供了一套预编译的调试工具链，其可在\
\href{https://github.com/sifive/freedom-tools/releases}{sifive/freedom-tools}\
下载。下载并解压后，可以将\texttt{riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86\_64-linux-ubuntu14/bin}添加到\texttt{PATH}。QEMU的文档声称已经附带了\texttt{OpenSBI}\cite{qemu-virt}，
但是Ubuntu 20.04的APT源中的QEMU并没有附带，所以仍然需要到\ \href{https://github.com/riscv-software-src/opensbi/releases/tag/v1.0}{OpenSBI Version 1.0}\
手动下载。我们需要的是\linebreak\texttt{opensbi-1.0-rv-bin/share/opensbi/lp64/generic/firmware/fw\_jump.bin}。为了方便后续使用，可以在\texttt{~/.bashrc}中加上\texttt{export RISCV\_BIOS=\textit{<PATH\_TO\_fw\_jump.bin>}}。

一切安装完毕后，可以用
\begin{lstlisting}
qemu-system-riscv64 -machine virt -nographic -bios $RISCV_BIOS -device loader,file=build/riscv64gc-unknown-none-elf/release/dev-test.bin,addr=0x80200000 -s -S
\end{lstlisting}
启动系统。用
\begin{lstlisting}
riscv64-unknown-elf-gdb -ex 'file build/riscv64gc-unknown-none-elf/release/dev-test' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'
\end{lstlisting}
进行交互式调试。

\begin{figure}[tbh!]
\centering
\includegraphics[width=0.9\linewidth]{assets/debug}
\caption{调试}
\label{fig:debug}
\end{figure}

\begin{figure}[tbh!]
\centering
\includegraphics[width=0.9\linewidth]{assets/run}
\caption{运行结果}
\label{fig:run}
\end{figure}

\subsection{QEMU性能测试}
Unikernel以高性能著称，性能也是评价unikernel的重要指标。
然而遗憾的是，由于我们无法得到RISC-V物理机，而QEMU仿真硬件架构本身
会带来巨大的性能损失，所以我们很难准确评估我们写的Runikraft的性能。为了相对准确的估计Runikraft
的性能，可以测试QEMU仿真本身带来的性能损失，然后可以用QEMU上的运行时间除以性能损失比\footnote{riscv64时间÷ x86-64时间}，估计真实RISC-V
硬件上的运行时间。

我们用组员张子辰同学的数据结构课程的大作业
\href{https://github.com/WCIofQMandRA/huffman_compressor}{Huffman树压缩器}做了基准测试。
测试结果见表\ \ref{table:test}。
\begin{longtable}{|c||>{\ttfamily}r|>{\ttfamily}r|>{\ttfamily}r||>{\ttfamily}r|>{\ttfamily}r|>{\ttfamily}r|}
\caption{QEMU基准测试}\label{table:test}\\
\hline
\multirow{2}{*}{文件}&\multicolumn{3}{c|}{压缩/s}&\multicolumn{3}{c|}{提取/s}\\\cline{2-7}
&\multicolumn{1}{c|}{x86-64}&\multicolumn{1}{c|}{riscv64}&\multicolumn{1}{c||}{损失比}&\multicolumn{1}{c|}{x86-64}&\multicolumn{1}{c|}{riscv64}&\multicolumn{1}{c|}{损失比}\\\hline
\endfirsthead
test01&0.019& 0.079&4.16&0.009&0.058&6.44\\\hline
test02&0.040& 0.134&3.35&0.011&0.083&7.55\\\hline
test03&1.075& 3.054&2.84&0.316&1.624&5.14\\\hline
test04&1.114& 3.285&2.95&0.272&1.701&6.23\\\hline
test05&0.715& 2.085&2.92&0.201&1.116&5.55\\\hline
test06&5.001&14.121&2.82&1.177&7.018&5.96\\\hline
\end{longtable}

测试脚本是\href{https://github.com/WCIofQMandRA/huffman_compressor/blob/8ab200b656a0e087e27480fcbcae4000a59f6b47/test/benchmark.sh}{test/bencmark.sh}。
原始记录见我们的仓库的\href{https://github.com/OSH-2022/x-runikraft/tree/eca8a7575be96fb0a4dc311a8c60622c0e9b0aa5/reference/qemu-benchmark.log}{reference/qemu-benchmark.log}。

从测试结果可以看出，不同类型的程序的损失比并不相同，但是我目前并没有弄清楚
什么样的程序更容易造成性能损失。由于QEMU无法有效利用处理器的分值预测和高速缓存，
我猜测流水线友好和缓存友好的程序会因此较大的性能损失。考虑到内核的大部分操作不涉及大范围的
寻址，可以认为系统内核属于会引起较大性能损失的程序，所以我们把QEMU仿真带来的性能损失视为5。

\section{创新点}
与先前用Rust改写FreeRTOS的小组类似，我们的项目偏重工程，没有理论上的创新点。
由于我们了解的所有用Rust写的操作系统都或多或少的使用了unstable的特性，我们用stable特性
编写unikernel也不失为一种技术上的创新。
\section{概要设计}
\subsection{架构}
Runikraft的架构与Unikraft几乎相同。
\begin{figure}[!hbt]
\centering
\begin{minipage}{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{assets/Unikraft-architecture.png}
\caption{Unikraft的架构}\label{fig:unikraft-arch}
\end{minipage}
\begin{minipage}{0.49\linewidth}
\centering
\includegraphics[width=\linewidth]{assets/Runikraft-architecture.pdf}
\caption{Runikraft的架构}\label{fig:runikraft-arch}
\end{minipage}
\end{figure}
平台层将不同的平台封装成通用的\texttt{rkplat} API，它提供与平台/架构密切相关的功能，
比如外设驱动、外中断处理、内存分页、定时器、原子操作、内存屏障，我们只计划支持RISC-V+QEMU virt
一种平台。如果时间不足，我们可以将现成的OpenSBI\cite{5}\cite{6}封装成\texttt{rkplat} API。

\texttt{rknetdev}、\texttt{rkblkdev}、\texttt{rktime}、\texttt{rkswrand}、\texttt{rkboot}
五个APIs的功能与平台密切相关，
但是为了降低开发和维护难度，它们并没有直接实现，而是在\texttt{rkplat}提供的初级抽象的基础上实现。
\texttt{rknetdev}和\texttt{rbblkdev}对应图\ \ref{fig:unikraft-arch}\ 的⑦和⑧，
它们分别提供网络设备和块设备的支持。
%与Unikraft的实现类似，这两个APIs的构造函数的参数接受指向\texttt{trait RKplat}的指针。
\texttt{rktime}提供获取和修改系统时间的API，\texttt{rkswrand}提供密码学安全的随机数，
\texttt{rkboot}负责完成系统的初始化并将控制权转交给用户的代码。

\texttt{rkshed}和\texttt{rklock}是两个与调度器有关的APIs，前者负责创建、调度、撤销线程，后者负责线程间
的同步和互斥。Runikraft支持多种调取器，比如，图\ \ref{fig:runikraft-arch}\ 中的RR的时间片轮转调度器、
Mul-qu是多重队列调取器、EDF是截止日期有限调度器。我们计划先实现RR调度器。当然，为了系统镜像的轻量性，
用户可以不使用任何调取器，这时，\texttt{rkshed}和\texttt{rklock}会被编译成空API，创建线程的行为
将和函数调用相同。这保证了大部分使用仅仅并行加速的程序仍然能正确运行。

Runikraft选择性地提供线程通信模块，如UNIX风格的信号（\texttt{rksignal}），信箱（\texttt{rkmbox}），
无锁的环形缓冲队列（\texttt{rkring}）。

我们目前没有计划区分线程和进程，Runikraft的线程同时具有传统的OSes的线程和进程的特性：
线程之间没有隔离措施，但是线程之间又可以使用进程通信的方法更安全地同步。

\texttt{rkalloc}是分配器API，它的后端可以是\texttt{buddy}、\texttt{tinyalloc}、\texttt{tlsf}、
\texttt{mimalloc}等分配器。
不过，我们可能只会实现其中的一个。

Runikraft还提供了一些工具模块，比如调试工具\texttt{rkdebug}、命令行参数分析工具\texttt{rkparam}。

在 Unikraft 中,文件系统 API vfscore 是 POSIX 兼容层的一部分,我们沿用了它的设
计,将 \texttt{vfscore} 放在了兼容层。Runikraft计划支持RAM上的临时文件系统和Plan 9 OS的9fps。

位于最顶层的是语言标准库，这一层可以帮助Runikraft支持多种语言。
虽然语言标准库层被画在了兼容层之上，但它其实是直接用OS元件层的APIs实现的，这能避免分层系统
的低效。
我们只打算实现Rust标准库和C标准库的部分内容。

\subsection{改写方法}

\subsection{日程安排}

\section*{许可协议}
本文档以知识共享署名 4.0 国际 (CC BY 4.0)许可证发布。

\vspace{2ex}
\noindent\textbf{\large 您可以自由地}：
\begin{description}
\item[共享] 在任何媒介以任何形式复制、发行本作品；
\item[演绎] 修改、转换或以本作品为基础进行创作
在任何用途下，甚至商业目的。
\end{description}

\vspace{2ex}
\noindent\textbf{\large 惟须遵守下列条件}：
\begin{description}
\item[署名] 您必须给出适当的署名，提供指向本许可协议的链接，
同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，
但是不得以任何方式暗示许可人为您或您的使用背书。
\item[没有附加限制] 您不得使用法律术语或者技术措施，从而限制其他人
做许可协议允许的事情。
\end{description}

\vspace{2ex}
\noindent\textbf{\large 声明}：

您不必因为公共领域的作品要素而遵守许可协议，或者您的使用被可适用的例外或限制所允许。

不提供担保。许可协议可能不会给与您意图使用的所必须的所有许可。
例如，其他权利比如形象权、隐私权或人格权可能限制您如何使用作品。

本许可证的全文位于：\\
\centerline{\url{https://creativecommons.org/licenses/by/4.0/legalcode.zh-Hans}}
\bibliographystyle{IEEEtran}
\bibliography{feasibility-report}
\end{document}
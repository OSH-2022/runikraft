# 技术依据

> by 陈建绿 2022/4/4

## Rust 编写操作系统的可行性分析

Rust 是一门系统级编程语言，被设计为保证内存和线程安全，防止段错误产生。作为系统级编程语言，它的基本理念是 “零开销抽象”。理论上来说，它的速度与 C/C++ 同级。Rust 可以被归为通用的、多范式、编译型的编程语言，类似 C/C++。与这两门编程语言不同的是，Rust 是线程安全的。Rust 编程语言的目标是，创建一个安全和并发的软件系统。它强调安全性、并发和内存控制。尽管 Rust 借用了 C/C++ 的语法，却杜绝了空指针和悬挂指针，而这二者是 C/C++ 中系统崩溃、内存泄露和不安全代码的根源。

下面从 Rust 的语言特性角度分析 Rust 编写操作系统的可行性。

### Rust 的语言特性

#### 1. 所有权与生命周期

##### （1）所有权规则的具体内容

一般来讲，所有的程序都需要管理自己在运行时使用的计算机内存空间。某些使用垃圾回收（Garbage Collector, GC）机制的语言会在运行时定期检查并回收那些没有被继续使用的内存；而在另外一些语言中，程序员需要手动地分配和释放内存。Rust 则采用了与众不同地第三种方式：它使用包含特定规则地所有权系统来管理内存，这套规则允许编译器在编译过程中执行检查工作，而不会产生任何的运行时开销。

Rust 中具体的所有权规则有下面几条[^1]：

- Rust 中的每一个值都有一个对应的变量作为它的**所有者（owner）**；
- 在同一时间内，值有且只有一个所有者；
- 当所有者离开自己的作用域时，它持有的值就会被释放掉。

##### （2）生命周期的具体含义

Rust 中的引用（也即 Rust 中最常用的指针）都有自己的**生命周期（lifetime）**，它对应着引用保持有效性的作用域。生命周期最主要的目标在于避免悬垂引用（在一些其他语言中称为悬垂指针）。Rust 中的**借用检查器（borrow checker）**就会用来比较不同的作用域（换言之，就是不同引用的生命周期）并确定所有借用的合法性。

#### 2. Option枚举代替空值

Rust 并没有像许多其他语言一样支持空值。这是因为历史经验告诉我们，空值曾导致了无数的错误、漏洞和系统崩溃。空值的问题在于，当我们尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。因为空或非空的属性被广泛散布在程序中，所以开发者很难避免引起类似的问题。

Rust 设计者们深知空值带来的问题，因此它们使用Option枚举来替代空值：

```rust
enum Option<T> {
	Some(T),
	None,
}
```

`Option<T>`与`T`并不是相同的类型，所以编译器不会允许我们像使用普通值那样去直接使用`Option<T>`的值。为了使用`Option<T>`中可能存在的`T`，我们必须将它转换为T。一般而言，这能帮助我们避免使用空值时最常见的一个问题：假设某个值存在，实际上却为空。

这一设计十分有效地限制了空值泛滥，从而增加了 Rust 代码的安全性。

#### 3. 无畏并发

安全并且高效地处理并发编程是 Rust 的另一个主要目标。从历史上看，并发编程往往是非常困难且容易出错的，而 Rust 则希望改变这种情形。

Rust 的设计者们设计的所有权和类型系统这套强有力的工具集不仅能够帮助我们管理内存安全，还能帮助我们解决并发问题。借助所有权和类型检查，许多并发问题可以在 Rust 中暴露为编译时错误而不是运行时错误。即代码中的并发缺陷可以在开发过程中被及时修复，而不必等到它们被发布至生产环境后暴露出来。

#### 4. unsafe Rust

所谓 unsafe Rust 是指它不会强制实施安全保障，在使用关键字`unsafe`标记后，我们便可以在被标记地代码块中使用不安全代码。unsafe Rust 之所以存在，主要有两个原因：

- 静态分析从本质上讲是保守的。即代码编译器在判断一段代码是否安全时，它总算宁可错杀一些合法的程序也不会接受可能非法的代码。而某些时候，我们可以十分确信某段代码是安全的，这时如果无法通过编译器的检查，我们便可以使用 unsafe Rust 来让编译器信任我们能保证程序的安全。
- 底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全的操作，那么某些底层任务可能根本就完成不了。Rust 作为一门系统语言需要能够进行底层编程，它应当运行程序员直接与操作系统打交道。

这样一来，在必要的时候，我们就可以使用`unsafe`标记来使我们的代码编写更加方便。

### Rust 保证内存/线程安全的方式

#### 1. 内存安全问题

在高级语言中，某个内存位置要在程序中能被访问，必然就会与一个或多个变量建立关联关系。而这自然就会引出三个问题：

1. 内存的不正确访问引发的内存安全问题；
2. 多个变量指向同一块内存区域导致的数据一致性问题；
3. 变量在多个线程中传递导致的数据竞争问题。

而由第一个问题引出的内存安全问题一般有5个典型情况：

- 使用未初始化的内存
- 对空指针解引用
- 悬垂指针（使用已经被释放的内存）
- 缓冲区溢出
- 非法释放内存（释放未分配的指针或重复释放指针）

这些问题在C/C++中都是需要开发者非常小心地自己处理。而 Rust 的语言特性则为上面的问题提供了解决方案[^3]：

|       问题       |                Rust 的解决方案                 |
| :--------------: | :--------------------------------------------: |
| 使用未初始化内存 |          编译器禁止变量读取未赋值变量          |
|  对空指针解引用  |           使用`Option`枚举替代空指针           |
|     悬垂指针     |            生命周期标识与编译器检查            |
|    缓冲区溢出    |    编译器检查，拒绝超越缓冲区边界的数据访问    |
|   非法释放内存   | 语言级的 RAII 机制，唯一的所有者才有权释放内存 |

> 注：RAII 机制是C++中的释放资源的模式，称作资源获取即初始化（Resource Acquisition Is Initialization, RAII）。

#### 2. 线程安全问题

在大部分现代操作系统中，执行程序的代码会运行在进程（process）中，操作系统会同时管理多个进程。类似地，程序内部也可以拥有多个同时独立运行地独立部分，用来运行这些独立部分地就叫做线程（thread）。

将程序中的计算操作拆分支多个进程可以提高性能，但这也增加了程序的复杂度，因为不同线程在执行过程中的具体顺序是无法确定的。这可能会导致一系列的问题，比如：

- 当多个线程以不一致的顺序访问数据或资源时产生的竞争状态（race condition）;
- 当两个线程同时尝试获取对方持有的资源时产生的死锁（deadlock），它会导致这两个进程无法继续运行；
- 只会出现在特定情形下且难以稳定重现和修复的bug。

许多操作系统都提供了用于创建新线程的API。于是一些编程语言是直接利用操作系统API来创建线程，这种模型常被称作**1:1模型**，它意味着一个操作系统线程对应一个语言线程。还有一些编程语言提供了它们自身特有的线程实现，这种由程序语言提供的线程常被称为**绿色线程(green thread)**，这种模型也被称为**M:N模型**，它表示M个绿色线程对应着N个系统线程，这里的M与N不必相等。

每一种模型都有其自身的优势和取舍。Rust 标准库只提供了1:1线程模型的实现，这几乎不需要运行时。

> 注：在当前语境下，运行时（runtime）指语言中那些被包含在每一个可执行文件中的代码。

Rust 通过一整套设计非常精良的基础设施来保证这一点[^3]，这些基础设施配合类型检查和借用模型“强迫”程序员写出正确的代码，把别的语言在运行时的崩溃或泄露暴露在编译期，从而保证线程安全。

##### 基础设施

1. 进行语义限制的`Send` / `Sync` `Trait`
2. 共享不可变所有权的`Arc` (`Rc`的多线程版本)
3. 提供内部可变性的`Mutex` / `Rwlock`
4. 管道模型`channel`
5. 其他的一些线程相关的API

##### 线程相关的常见API与设施

1. `std::thread::spawn`，`spawn`接收一个**闭包**并执行,返回一个`JoinHandle`类型的值，它拥有线程所有权；
2. `join()`函数，该函数作用在线程句柄`JoinHandle`类型的值上，使得父线程能够等待子线程执行完毕；
3. `move`+闭包，`move`闭包常常与`thread`和`spawn`一起使用，它允许我们在一个线程中使用另外一个线程的数据，使用`move`关键字强制闭包获取其使用的环境值的所有权。

Rust 所拥有的这些设施以及自身的特性可以让我们编写出正确的代码从而保证线程安全。

### Rust 与 C 交互

我们的项目是使用 Rust 改写 Unikraft，最终实现一个 Rust 编写的 Unikernel。而 Unikraft 是使用 C 编写的，后面我们在实现的过程中可能会因为某些原因保留少部分 C 代码，因此需要在 Rust 中调用这部分外部代码，即要实现 Rust 与 C 的交互。Rust 中提供了`extern`关键字来简化创建和使用外部接口（Foreign Function Interface, FFI）的过程。FFI 是编程语言定义函数的一种方式，它允许其他（外部的）编程语言来调用这些函数。

下面是一个集成了C标准库中的`abs`函数的示例代码：

```rust
extern "C" {
	fn abs(input: i32) -> i32;
}
fn main(){
	unsafe {
		println!("Absolue value of -3 according to C: {}", abs(-3));
	}
}
```

这段代码在`extern "C"`块中列出了它想要调用的外部函数和签名，其中的“C”指明了外部函数使用的应用二进制接口（Application Binary Interface, ABI）：它被用来定义函数在汇编层面的调用方式。

要在其他语言中调用 Rust 函数，同样可以使用`extern`来创建一个允许其他语言调用 Rust 函数的接口。创建时需要将`extern`关键字及对应的 ABI 添加到函数签名的`fn`关键字前，并为该函数添加`#[no_mangle]`注解来避免 Rust 在编译时改变它的名称。下面是一个可以在编译并链接后被 C 语言代码访问的函数定义：

```rust
#[no_mangle]
pub extern "C" fn call_from_c() {
	println!("Just called a Rust function from C!");
}
```

这一类型的`extern`功能不需要使用`unsafe`。

### 总结

Rust 所拥有的这些语言特性，使得它能够保证内存安全和线程安全，而且它的速度和C/C++同级；同时 Rust 支持与外部代码进行交互以及 unsafe Rust，这也增加了它的灵活性。因此我们可以自信地说，使用 Rust 编写操作系统是十分可行的。

[^1]: [美]Steve Klabink,等.Rust权威指南[M/OL].毛靖凯,等,译.北京:电子工业出版社,2020.
[^2]: https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rust_ownership.html
[^3]: [Rust线程安全编程分析——知乎](https://zhuanlan.zhihu.com/p/138394529Rust)